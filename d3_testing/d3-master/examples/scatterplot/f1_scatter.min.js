
var dataset = [],
    vis, width = 450,
    height = 590,
    padding = {
        top: 25,
        right: 0,
        bottom: 15,
        left: 200
    }, graphHeight = 400,
    typeField = 'expttype',
    graphedItemCol = 'exptname',
    graphType = 'scatter',
    xLabel = 'Mammalian conservation',
    yLabel = 'Human diversity (inverted scale)',
    axisHeight = 30,
    graphType = 'scatter',
    xScale = d3.scale.linear(), // Initialise a scale (mapping from input domain to output range: e.g. [100,300] -> [500,700])
    yScale = d3.scale.linear(), // Initialise a scale
    rAxis = 4,
    padd = rAxis / 2 + 1,
    xAxis, yAxis, colors = ["#efc57c", "#846a75", "#9ab4bf", "#d0472b", "#b2dd95", "#729c6e", "#FDDBC7", "#9ed2eb", "#ac3a2e", "#f2947b", "#9c8e6b", "#B35806", "#41517b", "#9ed2eb", "#444444"],
    xExtent, yExtent, datacontainer, overlay, xCol = "x",
    yCol = "y";
var is_touch_device = 'ontouchstart' in window;
 
function slug(string) {
    return string.replace(/([^a-z0-9])/ig, "-").toLowerCase()
}
var trueWidth = width + padding.left + padding.right + 160,
    winW = window.innerWidth,
    winH = window.innerHeight,
    multiplier = (winW >= trueWidth) ? 1 : (winW - 26) / trueWidth;
if (winW > 800) {
    padding.right = 100
}
function processData(data) {
    var processed = [],
        dataTypes = {}, counter = 1;
    for (var i = 0; i < data.length; i++) {
        var className = "",
            dpoint = {
                id: i,
                x: data[i][xCol],
                y: data[yCol],
                jsevent: data[i][graphedItemCol],
            };
			console.log("dpoint is x: "+data[i][xCol]+" y: "+data[yCol]+"  jsevent: "+data[i][graphedItemCol]);
        for (var attribute in data[i]) {
            if (data[i].hasOwnProperty(attribute)) {
                dpoint[attribute] = data[i][attribute]
            }
        }
        if (typeField !== undefined) {
            if (typeof dataTypes[dpoint[typeField]] == "undefined") {
                dataTypes[dpoint[typeField]] = {
                    id: counter - 1,
                    className: 'datatype-' + counter,
                    name: dpoint[typeField],
                    slug: slug(dpoint[typeField])
                };
                counter = counter + 1
            }
            dpoint.type = dataTypes[dpoint[typeField]]
        } else {
            dataTypes[dpoint['type']] = {
                id: 1,
                className: 'datatype-1',
                name: "Type One",
                slug: 'type-one'
            };
            dpoint.type = dataTypes[dpoint['type']]
        }
        processed.push(dpoint)
    };
    return processed
}
function typesList(data) {
    var l = data.length,
        typeNames = {}, select = document.getElementById("data-types"),
        list = "";
    while (l--) {
        if (typeof typeNames[data[l].type.name] == "undefined") {
            typeNames[data[l].type.id] = {
                "typeclass": data[l].type.className,
                "name": data[l].type.name
            }
        }
    }
    if (typeNames[1] !== undefined) {
        var typeList = d3.nest().key(function (d, i) {
            return d[i].name
        }).entries(typeNames);
        for (var key in typeNames) {
            if (typeNames.hasOwnProperty(key)) {
                list += '<li class="' + typeNames[key].typeclass + '" style="border-color:' + colors[key] + '"><label><input type="checkbox" name="' + slug(typeNames[key].name) + '" class="dt-checkbox" checked="checked" value="' + slug(typeNames[key].name) + '">' + typeNames[key].name + '</label></li>'
            }
        }
        select.innerHTML = list
    }
}
function activeTypes(data) {
    var typesToDisplay = [];
    $("#data-types input[type='checkbox']:checked").each(function () {
		console.log("adding type "+$(this).val());
        typesToDisplay.push($(this).val())
    });
    var activeData = data.filter(function (dpoint) {
        return typesToDisplay.indexOf(dpoint.type.slug) !== -1
    });
    return activeData
}
function setminMax(data) {
    xExtent = d3.extent(data, function (d) {
        //console.log("min is "+d.x)
		return +d.x
    });
    yExtent = d3.extent(data, function (d) {
        //console.log("max is "+d.y)
        return +d.y
    })
}
function tooltip(d) {
    var contentSt = '';
    if (typeField !== undefined) {
        contentSt = "<p class='type-label'>" + d.type.name + "</p>"
    }
    contentSt += "<p class='x-val'>" + xLabel + ": " + d.x + "</p>";
    contentSt += "<p class='y-val'>" + yLabel + ": " + d.y + "</p>";
    overlay.classed("overlay-shown", true).attr("width", multiplier * width - 40 + "px").style("top", multiplier * (padding.top + graphHeight + axisHeight + padd) + "px").transition().duration(400).select("#box-arrow").style("left", multiplier * (xScale(d.x) - 11) + "px");
    if (winW < 500) {
        overlay.style("left", "0").select('#box-arrow').style("display", "none")
    }
    var title = '';
    title += d.jsevent;
    overlay.select("h2").html(title);
    overlay.select(".overlay-content").html(contentSt);
    overlay.select("p.type-label").style("border-left", "4px solid" + colors[d.type.id])
}
function update(data) {
    if (typeField !== undefined) {
        var activeData = activeTypes(data)
    } else {
        var activeData = data
    }
    var graphTypesList = document.getElementById('graph-types');
    if (typeof (graphTypesList) != 'undefined' && graphTypesList != null) {
        graphType = $('input[name=graphType]:checked', '#controls').val()
    }
    draw(activeData)
}
function draw(data) {
    var points = datacontainer.selectAll(".point").data(data, function (d) {
        return d.id
    });
    points.enter().append("circle").attr("id", function (d) {
        return d.jsevent + "_" + d.type.slug
    }).attr("class", function (d) {
        return d.type.slug + " point"
    }).attr("cx", function (d) {
        return xScale(+d.x)
    }).attr("cy", function (d) {
        return yScale(+d.y) + padd
    }).attr("r", rAxis).attr("data-xVal", function (d) {
        return d.x
    }).attr("data-yVal", function (d) {
        return d.y
    }).style("fill", function (d) {
        return colors[d.type.id]
    }).style("opacity", 0).on("mouseover", function (d) {
        tooltip(d)
    }).on("touchend", function (d) {
        tooltip(d)
    }).append("svg:title").text(function (d) {
        return d.jsevent
    });
    points.transition().duration(500).ease("exp").style("opacity", .8).attr("cx", function (d) {
        return xScale(+d.x)
    }).attr("cy", function (d) {
        return yScale(+d.y) + padd
    });
    points.exit().transition().duration(200).ease("exp").style("opacity", 0).remove()
}
function showCords() {
    var mx = d3.mouse(this)[0] - padding.left - 1,
        my = d3.mouse(this)[1] - padding.top - 1;
    if (my < yExtent[0]) {
        my = yExtent[0]
    } else if (my > graphHeight) {
        my = graphHeight + padd
    };
    if (mx < xExtent[0]) {
        mx = xExtent[0] + 1
    } else if (mx > width) {
        mx = width - 1
    };
    d3.select(".x.marker").attr("x1", mx).attr("x2", mx);
    d3.select(".y.marker").attr("y1", my).attr("y2", my);
    d3.select(".cords-txt").text(Math.round(xScale.invert(mx + 1) * 100000) / 100000 + ", " + (Math.round(yScale.invert(my - padd + 1) * 100000) / 100000)).attr("transform", "translate(" + (mx + 10) + "," + (my - 8) + ")")
	//console.log("coords: "+Math.round(xScale.invert(mx + 1) * 100000) / 100000 + ", " + (Math.round(yScale.invert(my - padd + 1) * 100000) / 100000)).attr("transform", "translate(" + (mx + 10) + "," + (my - 8) + ")")

}
function setCrossHairs() {
    if (!is_touch_device) {
        var targets = datacontainer.append("svg:g").attr("class", "crosshair");
        targets.append("svg:line").attr("x1", -5).attr("x2", -5).attr("y1", 0).attr("y2", graphHeight + padd).attr("class", "x marker").attr("stroke", "#666").attr("stroke-width", "1px").attr("stroke-dasharray", "1,2");
        targets.append("svg:line").attr("x1", 0).attr("x2", width).attr("y1", -5).attr("y2", -5).attr("class", "y marker").attr("stroke", "#666").attr("stroke-width", "1px").attr("stroke-dasharray", "1,2");
        vis.append("svg:text").attr("dx", padding.left).attr("dy", padding.top).attr("text-anchor", "start").attr("class", "cords-txt");
        vis.on("mousemove", showCords)
    }
}
function setXAxis() {
    xScale.domain(xExtent).range([12, width - 14]);
	// scale is a mapping function between input - output
	// domain is input array
	// range is output array
	
	// Initialise x Axis using 
	// scale "xScale"
	// subdivision: produces one minor tick per major tick,
    xAxis = d3.svg.axis().tickSubdivide(true).scale(xScale);
    vis.append("svg:rect").attr("width", width).attr("height", axisHeight).attr("transform", "translate(" + padding.left + "," + (padding.top + graphHeight + padd) + ")").attr("fill", "#eee");
    vis.append("svg:g").attr("class", "x axis").attr("transform", "translate(" + padding.left + "," + (padding.top + graphHeight + padd) + ")").call(xAxis);
    vis.append("svg:text").attr("dx", 0).attr("dy", "2em").attr("text-anchor", "middle").text(xLabel).attr("class", "xLabel").attr("transform", "translate(" + (padding.left + width / 2) + "," + (graphHeight + +padding.top + axisHeight) + ")")
}
function setYAxis() {
    var yStart = yExtent[0];
    yScale.domain([yExtent[1], yStart]).range([padd, graphHeight]);
	// scale is a mapping function between input - output
	// domain is input array
	// range is output array
	
	// Initialise x Axis using 
	// scale "xScale"
	// subdivision: produces one minor tick per major tick,
    yAxis = d3.svg.axis().scale(yScale).tickSize(8).orient("left").tickSubdivide(false);
    vis.append("svg:g").attr("class", "y axis").attr("transform", "translate(" + padding.left + "," + (padding.top + padd) + ")").call(yAxis);
    vis.append("svg:text").attr("dx", 0).attr("dy", 0).attr("text-anchor", "middle").text(yLabel).attr("class", "yLabel").attr("transform", "translate(" + padding.left / 3 + "," + graphHeight / 2 + ")rotate(-90)")
}
function init() {
    vis = d3.select("#interactive-fig");
	console.log("svg selected")
    if (winW < 800) {
        padding.left = 100
    }
    vis.attr("width", width + padding.left + padding.right).attr("height", multiplier * (height + padding.top + padding.bottom)).attr("viewBox", "0 0 " + (width + padding.left + padding.right) + " " + (height + padding.top + padding.bottom)).attr("preserveAspectRatio", "xMinYMin meet");
    setminMax(dataset);
    setXAxis();
    setYAxis();
    datacontainer = vis.append("svg:svg");
    datacontainer.attr("id", "datacontainer").attr("class", "datacontainer").attr("x", padding.left).attr("y", padding.top).attr("width", width).attr("height", graphHeight);
    typesList(dataset);
	console.log("updating2")
    update(dataset);
    setCrossHairs();
    overlay = d3.select("#overlay").style("left", multiplier * padding.left + "px").style("width", multiplier * (width - 42) + "px")
}
 
